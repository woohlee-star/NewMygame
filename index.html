<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Rainbow Breaker Sound Edition</title>
    <link rel="manifest" href="data:application/manifest+json,{'name':'RainbowBreaker','short_name':'Breaker','start_url':'.','display':'standalone','background_color':'#222222','theme_color':'#222222','orientation':'portrait'}">
    <style>
        body { margin: 0; background: #222; overflow: hidden; touch-action: none; font-family: sans-serif; }
        canvas { display: block; margin: 0 auto; background: #000; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        Level: <span id="level">1</span> | Life: <span id="lives">3</span><br>
        Bricks: <span id="count">0</span> / 70
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const levelDisplay = document.getElementById("level");
        const livesDisplay = document.getElementById("lives");
        const countDisplay = document.getElementById("count");

        let level = 1;
        let lives = 3;
        let bricksBroken = 0;
        let gameState = "READY"; 

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const rowCount = 7;
        const columnCount = 10;
        const brickPadding = 2;
        const brickWidth = (canvas.width / columnCount) - brickPadding;
        const brickHeight = 25;
        const rainbowColors = ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#9400D3"];
        // 도레미파솔라시 주파수 (시-라-솔-파-미-레-도 순서로 매칭하기 위해 역순 배치 가능)
        const scaleFrequencies = [987.77, 880.00, 783.99, 698.46, 659.25, 587.33, 523.25]; // 시(B5) ~ 도(C5)

        const paddleOffsetBottom = brickHeight * 3 + 60; 
        let paddleWidth = brickWidth; // 초기 크기 = 벽돌 크기
        const paddleHeight = 18;
        let paddleX = (canvas.width - paddleWidth) / 2;
        let paddleY = canvas.height - paddleOffsetBottom;

        let ballRadius = 9;
        let x, y, dx, dy, currentSpeed;
        let bricks = [];

        // 사운드 시스템 (Web Audio API)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playBell(row) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'triangle'; // 맑은 벨소리 느낌
            oscillator.frequency.setValueAtTime(scaleFrequencies[row], audioCtx.currentTime);

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.5);
        }

        function initLevel() {
            // 판 크기 설정: 레벨 1은 벽돌 크기, 이후 20%씩 감소 (최소 10% 제한)
            let calculatedWidth = brickWidth * Math.pow(0.8, level - 1);
            paddleWidth = Math.max(calculatedWidth, brickWidth * 0.1);
            
            bricksBroken = 0;
            currentSpeed = (3 + level) * 0.6; 
            
            bricks = [];
            for (let r = 0; r < rowCount; r++) {
                bricks[r] = [];
                for (let c = 0; c < columnCount; c++) {
                    let strength = (level >= 6 && r === 0) ? 2 : 1;
                    bricks[r][c] = { x: 0, y: 0, status: strength, color: rainbowColors[r] };
                }
            }
            resetBall();
            updateUI();
        }

        function resetBall() {
            x = paddleX + paddleWidth / 2;
            y = paddleY - ballRadius - 5;
            dx = currentSpeed * (Math.random() > 0.5 ? 1 : -1);
            dy = -currentSpeed;
            gameState = "READY";
        }

        function handleMove(inputX) {
            paddleX = inputX - paddleWidth / 2;
            if(paddleX < 0) paddleX = 0;
            if(paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
            if (gameState === "READY") x = paddleX + paddleWidth / 2;
        }

        canvas.addEventListener("touchmove", (e) => { e.preventDefault(); handleMove(e.touches[0].clientX); }, {passive: false});
        canvas.addEventListener("mousemove", (e) => { handleMove(e.clientX); });

        const startAction = () => { 
            if (audioCtx.state === 'suspended') audioCtx.resume(); // 브라우저 정책 대응
            if (gameState === "READY") gameState = "PLAYING"; 
        };
        canvas.addEventListener("touchstart", startAction);
        canvas.addEventListener("mousedown", startAction);

        function collisionDetection() {
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < columnCount; c++) {
                    let b = bricks[r][c];
                    if (b.status > 0) {
                        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            dy = -dy;
                            b.status--;
                            playBell(r); // 벽돌의 행(row)에 따라 다른 음계 재생
                            if (b.status === 0) {
                                bricksBroken++;
                                if ([20, 40, 60].includes(bricksBroken)) {
                                    dx *= 1.25; dy *= 1.25;
                                }
                            }
                            if (bricksBroken === rowCount * columnCount) {
                                level++;
                                initLevel();
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < columnCount; c++) {
                    if (bricks[r][c].status > 0) {
                        let bX = c * (brickWidth + brickPadding);
                        let bY = r * (brickHeight + brickPadding) + 80;
                        bricks[r][c].x = bX;
                        bricks[r][c].y = bY;
                        ctx.beginPath();
                        ctx.roundRect(bX, bY, brickWidth, brickHeight, 4);
                        ctx.fillStyle = bricks[r][c].color;
                        ctx.fill();
                        if (bricks[r][c].status === 2) {
                            ctx.strokeStyle = "white";
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                        ctx.closePath();
                    }
                }
            }

            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "white";
            ctx.fill();
            ctx.closePath();

            ctx.beginPath();
            ctx.roundRect(paddleX, paddleY, paddleWidth, paddleHeight, 8);
            ctx.fillStyle = "#00FF00";
            ctx.fill();
            ctx.closePath();

            if (gameState === "PLAYING") {
                if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
                if (y + dy < ballRadius) dy = -dy;
                if (y + dy > paddleY - ballRadius && y + dy < paddleY + paddleHeight) {
                    if (x > paddleX && x < paddleX + paddleWidth) {
                        let collidePoint = (x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
                        let angle = collidePoint * (Math.PI / 3);
                        let speed = Math.sqrt(dx * dx + dy * dy);
                        dx = speed * Math.sin(angle);
                        dy = -speed * Math.cos(angle);
                    }
                }
                if (y + dy > canvas.height) {
                    lives--;
                    if (lives <= 0) {
                        alert("GAME OVER!");
                        level = 1; lives = 3; initLevel();
                    } else { resetBall(); }
                }
                x += dx; y += dy;
                collisionDetection();
            }
            updateUI();
            requestAnimationFrame(draw);
        }

        function updateUI() {
            levelDisplay.innerText = level;
            livesDisplay.innerText = lives;
            countDisplay.innerText = bricksBroken;
        }

        initLevel();
        draw();
    </script>
</body>
</html>