<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Rainbow Breaker - Pro Ranking</title>
    <link rel="manifest" href="data:application/manifest+json,{'name':'RainbowBreaker','short_name':'Breaker','start_url':'.','display':'standalone','background_color':'#222222','theme_color':'#222222','orientation':'portrait'}">
    <style>
        body { margin: 0; background: #222; overflow: hidden; touch-action: none; font-family: 'Arial', sans-serif; }
        canvas { display: block; margin: 0 auto; background: #000; }
        
        /* 상단 점수 UI */
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; z-index: 10; font-weight: bold; }

        /* 랭킹 레이어 (팝업) */
        #ranking-layer {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; flex-direction: column; align-items: center; justify-content: center;
        }
        .ranking-container {
            background: #333; border: 3px solid #00FF00; padding: 25px; border-radius: 20px;
            width: 85%; max-width: 350px; text-align: center; color: white;
        }
        .rank-row { display: flex; justify-content: space-between; margin: 10px 0; padding: 10px; background: #444; border-radius: 8px; font-size: 18px; }
        .rank-row.new { background: #555; border: 2px solid #FFFF00; }
        .rank-name-input { width: 100px; background: #000; color: #FFFF00; border: 1px solid #FFFF00; text-align: center; text-transform: uppercase; font-weight: bold; }
        
        /* 버튼 디자인 */
        .btn-group { display: flex; gap: 10px; justify-content: center; margin-top: 20px; }
        .game-btn { padding: 12px 20px; border: none; border-radius: 8px; font-weight: bold; font-size: 16px; cursor: pointer; }
        .save-btn { background: #00FF00; color: #000; }
        .retry-btn { background: #FF4444; color: white; }
    </style>
</head>
<body>
    <div id="ui">
        LEVEL: <span id="level">1</span> | LIVES: <span id="lives">3</span><br>
        SCORE: <span id="score">0</span>
    </div>

    <div id="ranking-layer">
        <div class="ranking-container">
            <h2 id="rank-title" style="color:#00FF00; margin-top:0;">TOP 5 RANKING</h2>
            <div id="rank-list-items">
                </div>
            <div class="btn-group">
                <button id="save-btn" class="game-btn save-btn">SAVE RANKING</button>
                <button onclick="restartGame()" class="game-btn retry-btn">PLAY AGAIN</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const levelDisplay = document.getElementById("level");
        const livesDisplay = document.getElementById("lives");
        const scoreDisplay = document.getElementById("score");
        const rankingLayer = document.getElementById("ranking-layer");
        const rankListItems = document.getElementById("rank-list-items");
        const saveBtn = document.getElementById("save-btn");

        let level = 1; let lives = 3; let totalScore = 0; let bricksBroken = 0;
        let gameState = "READY"; 

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const rowCount = 7; const columnCount = 10;
        const brickPadding = 2; const brickWidth = (canvas.width / columnCount) - brickPadding;
        const brickHeight = 25;
        const rainbowColors = ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#9400D3"];
        const rowScores = [70, 60, 50, 40, 30, 20, 10];
        const scaleFrequencies = [987.77, 880.00, 783.99, 698.46, 659.25, 587.33, 523.25];

        const paddleOffsetBottom = brickHeight * 3 + 60; 
        let paddleWidth; const paddleHeight = 18; let paddleX; let paddleY = canvas.height - paddleOffsetBottom;
        let ballRadius = 9; let x, y, dx, dy, currentSpeed; let bricks = [];

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playBell(row) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'triangle'; osc.frequency.setValueAtTime(scaleFrequencies[row], audioCtx.currentTime);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.5);
        }

        function initLevel() {
            paddleWidth = (brickWidth * 2) * Math.pow(0.8, level - 1);
            paddleWidth = Math.max(paddleWidth, brickWidth * 0.1);
            paddleX = (canvas.width - paddleWidth) / 2;
            bricksBroken = 0; currentSpeed = (3 + level) * 0.6;
            bricks = [];
            for (let r = 0; r < rowCount; r++) {
                bricks[r] = [];
                for (let c = 0; c < columnCount; c++) {
                    bricks[r][c] = { x: 0, y: 0, status: (level >= 6 && r === 0) ? 2 : 1, color: rainbowColors[r] };
                }
            }
            resetBall(); updateUI();
        }

        function resetBall() {
            x = paddleX + paddleWidth / 2; y = paddleY - ballRadius - 5;
            dx = currentSpeed * (Math.random() > 0.5 ? 1 : -1); dy = -currentSpeed;
            gameState = "READY";
        }

        function handleMove(inputX) {
            if (gameState === "RANKING") return;
            paddleX = inputX - paddleWidth / 2;
            if(paddleX < 0) paddleX = 0; if(paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
            if (gameState === "READY") x = paddleX + paddleWidth / 2;
        }

        canvas.addEventListener("touchmove", (e) => { e.preventDefault(); handleMove(e.touches[0].clientX); }, {passive: false});
        canvas.addEventListener("mousemove", (e) => { handleMove(e.clientX); });
        canvas.addEventListener("mousedown", () => { if (gameState === "READY") gameState = "PLAYING"; });
        canvas.addEventListener("touchstart", () => { if (gameState === "READY") gameState = "PLAYING"; });

        function checkRanking() {
            let highScores = JSON.parse(localStorage.getItem("breaker_rankings") || "[]");
            const newRankIndex = highScores.findIndex(s => totalScore > s.score);
            const isTop5 = highScores.length < 5 || newRankIndex !== -1;

            if (isTop5) {
                gameState = "RANKING";
                showRankingInput(highScores);
            } else {
                restartGame();
            }
        }

        function showRankingInput(scores) {
            rankingLayer.style.display = "flex";
            rankListItems.innerHTML = "";
            
            // 임시로 내 점수를 포함한 새로운 리스트 생성
            let tempScores = [...scores, { name: "ENTER...", score: totalScore, isNew: true }];
            tempScores.sort((a, b) => b.score - a.score);
            tempScores = tempScores.slice(0, 5);

            tempScores.forEach((s, i) => {
                const row = document.createElement("div");
                row.className = `rank-row ${s.isNew ? 'new' : ''}`;
                if (s.isNew) {
                    row.innerHTML = `<span>${i+1}. <input type="text" id="new-name" class="rank-name-input" maxlength="8" value="PLAYER"></span> <span>${s.score}</span>`;
                    saveBtn.onclick = () => saveRanking(i);
                    saveBtn.style.display = "block";
                } else {
                    row.innerHTML = `<span>${i+1}. ${s.name}</span> <span>${s.score}</span>`;
                }
                rankListItems.appendChild(row);
            });
            if (!tempScores.find(s => s.isNew)) saveBtn.style.display = "none";
        }

        function saveRanking() {
            const nameInput = document.getElementById("new-name");
            const name = nameInput.value.trim().toUpperCase() || "PLAYER";
            let highScores = JSON.parse(localStorage.getItem("breaker_rankings") || "[]");
            highScores.push({ name: name, score: totalScore });
            highScores.sort((a, b) => b.score - a.score);
            localStorage.setItem("breaker_rankings", JSON.stringify(highScores.slice(0, 5)));
            rankingLayer.style.display = "none";
            restartGame();
        }

        function restartGame() {
            rankingLayer.style.display = "none";
            level = 1; lives = 3; totalScore = 0; initLevel();
        }

        function collisionDetection() {
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < columnCount; c++) {
                    let b = bricks[r][c];
                    if (b.status > 0) {
                        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            dy = -dy; b.status--; playBell(r);
                            if (b.status === 0) {
                                totalScore += rowScores[r]; bricksBroken++;
                                if ([20, 40, 60].includes(bricksBroken)) { dx *= 1.25; dy *= 1.25; }
                            }
                            if (bricksBroken === rowCount * columnCount) { level++; initLevel(); }
                        }
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < rowCount; r++) {
                for (let c = 0; c < columnCount; c++) {
                    if (bricks[r][c].status > 0) {
                        let bX = c * (brickWidth + brickPadding);
                        let bY = r * (brickHeight + brickPadding) + 80;
                        bricks[r][c].x = bX; bricks[r][c].y = bY;
                        ctx.beginPath(); ctx.roundRect(bX, bY, brickWidth, brickHeight, 4);
                        ctx.fillStyle = bricks[r][c].color; ctx.fill();
                        if (bricks[r][c].status === 2) { ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.stroke(); }
                    }
                }
            }
            ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI * 2); ctx.fillStyle = "white"; ctx.fill(); ctx.closePath();
            ctx.beginPath(); ctx.roundRect(paddleX, paddleY, paddleWidth, paddleHeight, 8); ctx.fillStyle = "#00FF00"; ctx.fill(); ctx.closePath();

            if (gameState === "PLAYING") {
                if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
                if (y + dy < ballRadius) dy = -dy;
                if (y + dy > paddleY - ballRadius && y + dy < paddleY + paddleHeight) {
                    if (x > paddleX && x < paddleX + paddleWidth) {
                        let cp = (x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
                        let angle = cp * (Math.PI / 3);
                        let s = Math.sqrt(dx * dx + dy * dy);
                        dx = s * Math.sin(angle); dy = -s * Math.cos(angle);
                    }
                }
                if (y + dy > canvas.height) {
                    lives--;
                    if (lives <= 0) checkRanking();
                    else resetBall();
                }
                x += dx; y += dy; collisionDetection();
            }
            updateUI(); requestAnimationFrame(draw);
        }

        function updateUI() {
            levelDisplay.innerText = level; livesDisplay.innerText = lives; scoreDisplay.innerText = totalScore;
        }

        initLevel(); draw();
    </script>
</body>
</html>